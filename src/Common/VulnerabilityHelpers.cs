using NuGet.Configuration;
using NuGet.Packaging.Core;
using NuGet.ProjectModel;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;

namespace Common
{
    internal static class VulnerabilityHelpers
    {
        internal static async Task GenerateVulnerabilitiesAsync(PackageSpec packageSpec, Dictionary<string, PackageDependencyNode> packageIdToNode, CancellationToken cancellationToken)
        {
            var sourceRepositories = GetHTTPSourceRepositories(packageSpec);
            var vulnerabilityChecker = new VulnerabilityChecker(sourceRepositories, new SourceCacheContext() { MaxAge = DateTimeOffset.UtcNow });

            foreach (var package in packageIdToNode)
            {
                var packageIdentity = (PackageIdentity)package.Value.Identity;
                if (await vulnerabilityChecker.IsPackageVulnerableAsync(packageIdentity, cancellationToken))
                {
                    package.Value.Identity.Vulnerable = true;
                }
            }

            static List<SourceRepository> GetHTTPSourceRepositories(PackageSpec projectPackageSpec)
            {
                using var settingsLoadContext = new SettingsLoadingContext();

                Dictionary<PackageSource, SourceRepository> sourceRepositoryCache = new();

                var settings = Settings.LoadImmutableSettingsGivenConfigPaths(projectPackageSpec.RestoreMetadata.ConfigFilePaths, settingsLoadContext);
                var sources = projectPackageSpec.RestoreMetadata.Sources;

                IEnumerable<Lazy<INuGetResourceProvider>> providers = Repository.Provider.GetCoreV3();

                foreach (PackageSource source in sources)
                {
                    if (source.IsHttp)
                    {
                        SourceRepository sourceRepository = Repository.CreateSource(providers, source, FeedType.Undefined);
                        sourceRepositoryCache[source] = sourceRepository;
                    }
                }

                return sourceRepositoryCache.Values.ToList();
            }
        }
    }
}