using Logging;
using Microsoft.Extensions.Logging;
using NuGet.Packaging.Core;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Protocol.Model;

namespace Common
{
    /// <summary>
    /// Decorates a package dependency node with vulnerability information.
    /// </summary>
    public class VulnerabilityInfoDecorator : IPackageDependencyNodeDecorator
    {
        private readonly ILogger _logger;
        private readonly List<SourceRepository> _sourceRepositories;
        private readonly SourceCacheContext _sourceCacheContext;
        private IReadOnlyList<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>>? _vulnerabilityData;
        private bool _vulnerabilityDataChecked;

        /// <summary>
        /// Creates a decorator.
        /// </summary>
        public VulnerabilityInfoDecorator(List<SourceRepository> sourceRepositories, SourceCacheContext sourceCacheContext)
        {
            _sourceRepositories = sourceRepositories ?? throw new ArgumentNullException(nameof(sourceRepositories));
            _sourceCacheContext = sourceCacheContext ?? throw new ArgumentNullException(nameof(sourceCacheContext));
            _logger = AppLogger.Logger;
        }

        /// <summary>
        /// Adds vulnerability information to the node.
        /// </summary>
        public async Task DecorateAsync(PackageDependencyNode dependencyNode, CancellationToken cancellationToken)
        {
            if (!_vulnerabilityDataChecked)
            {
                IReadOnlyList<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>>? loadedVulnerabilityData = await LoadVulnerabilitiesAsync(_sourceRepositories, _sourceCacheContext, cancellationToken);
                if (loadedVulnerabilityData is not null)
                {
                    _vulnerabilityData = loadedVulnerabilityData;
                }
                _vulnerabilityDataChecked = true;
            }

            if (_vulnerabilityData != null)
            {
                var packageIdentity = (PackageIdentity)dependencyNode.Identity;
                if (IsPackageVulnerable(_vulnerabilityData, packageIdentity))
                {
                    dependencyNode.Identity.Vulnerable = true;
                }
            }
        }

        private async Task<IReadOnlyList<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>>?> LoadVulnerabilitiesAsync(
        List<SourceRepository> sourceRepositories,
        SourceCacheContext sourceCacheContext,
        CancellationToken cancellationToken)
        {
            GetVulnerabilityInfoResult? allVulnerabilityData = await GetAllVulnerabilityDataAsync(sourceRepositories, sourceCacheContext, cancellationToken);

            if (allVulnerabilityData?.Exceptions is not null)
            {
                _logger.LogError(string.Format(Strings.Warning_VulnerabilityDataIssues,
                    allVulnerabilityData.Exceptions));
            }

            if (allVulnerabilityData is null || !IsAnyVulnerabilityDataFound(allVulnerabilityData.KnownVulnerabilities))
            {
                return null;
            }

            return allVulnerabilityData.KnownVulnerabilities;

            static bool IsAnyVulnerabilityDataFound(IReadOnlyList<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>>? knownVulnerabilities)
            {
                if (knownVulnerabilities is null || knownVulnerabilities.Count == 0)
                {
                    return false;
                }

                for (var i = 0; i < knownVulnerabilities.Count; i++)
                {
                    if (knownVulnerabilities[i].Count > 0) { return true; }
                }
                return false;
            }
        }

        internal static bool IsPackageVulnerable(
            IReadOnlyList<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>> vulnerabilityData,
            PackageIdentity packageIdentity)
        {
            foreach (var singleDataFile in vulnerabilityData)
            {
                if (singleDataFile.TryGetValue(packageIdentity.Id, out var vulnerabilityList))
                {
                    foreach (var vulnerabilityInfo in vulnerabilityList)
                    {
                        if (vulnerabilityInfo.Versions.Satisfies(packageIdentity.Version))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        internal static async Task<GetVulnerabilityInfoResult?> GetAllVulnerabilityDataAsync(
            List<SourceRepository> sourceRepositories,
            SourceCacheContext sourceCacheContext,
            CancellationToken cancellationToken)
        {
            List<Task<GetVulnerabilityInfoResult?>>? results = new(sourceRepositories.Count);

            foreach (SourceRepository source in sourceRepositories)
            {
                Task<GetVulnerabilityInfoResult?> getVulnerabilityInfoResult = GetVulnerabilityInfoAsync(source, sourceCacheContext, cancellationToken);
                if (getVulnerabilityInfoResult != null)
                {
                    results.Add(getVulnerabilityInfoResult);
                }
            }

            await Task.WhenAll(results);
            if (cancellationToken.IsCancellationRequested)
            {
                cancellationToken.ThrowIfCancellationRequested();
            }

            List<Exception>? errors = null;
            List<IReadOnlyDictionary<string, IReadOnlyList<PackageVulnerabilityInfo>>>? knownVulnerabilities = null;
            foreach (var resultTask in results)
            {
                GetVulnerabilityInfoResult? result = await resultTask;
                if (result is null) continue;

                if (result.KnownVulnerabilities != null)
                {
                    if (knownVulnerabilities == null)
                    {
                        knownVulnerabilities = new();
                    }

                    knownVulnerabilities.AddRange(result.KnownVulnerabilities);
                }

                if (result.Exceptions != null)
                {
                    if (errors == null)
                    {
                        errors = new();
                    }

                    errors.AddRange(result.Exceptions.InnerExceptions);
                }
            }

            GetVulnerabilityInfoResult? final =
                knownVulnerabilities != null || errors != null
                ? new(knownVulnerabilities, errors != null ? new AggregateException(errors) : null)
                : null;
            return final;

            static async Task<GetVulnerabilityInfoResult?> GetVulnerabilityInfoAsync(SourceRepository source, SourceCacheContext cacheContext, CancellationToken cancellationToken)
            {
                cancellationToken.ThrowIfCancellationRequested();
                IVulnerabilityInfoResource vulnerabilityInfoResource =
                    await source.GetResourceAsync<IVulnerabilityInfoResource>(cancellationToken);
                if (vulnerabilityInfoResource is null)
                {
                    return null;
                }
                return await vulnerabilityInfoResource.GetVulnerabilityInfoAsync(cacheContext, NuGet.Common.NullLogger.Instance, cancellationToken);
            }
        }
    }
}